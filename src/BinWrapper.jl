const kbmag_bin_dir = joinpath(dirname(@__FILE__), "..", "deps", "usr", "bin")

"""
    low_level_exec(cmd::Cmd; input::String = "", tempfile::Bool = false)

Execute `cmd` as a system command. The `input` parameter is passed to the standard input and it sould _not_ be terminated. The `tempfile` parameter determines whether to use file-based (`true`) or memory-based (`false`) implementation. The function returns a tuple of stdout (`out`), stderr (`err`) and return status (`ret`) of `cmd`.

The memory-based implementation uses `IOBuffer` (VERSION >= 1.1) or `Pipes` (VERSION < 1.1).

# Examples
```julia-repl
julia> KBmag.low_level_exec(`cat`; input = "abc")
abc
```

```julia-repl
julia> KBmag.low_level_exec(`echo abc`)
abc
```
"""
function low_level_exec(cmd::Cmd; input::String = "", tempfile::Bool = false)
  # tempfile-based implementation
  if tempfile
    # create temporary files
    cmdin_p, cmdin    = mktemp()
    cmdout_p, cmdout  = mktemp()
    cmderr_p, cmderr  = mktemp()

    # save input
    write(cmdin, input)
    close(cmdin)
    cmdin = open(cmdin_p)

    # run a process
    process = run(pipeline(ignorestatus(cmd), stdin=cmdin, stdout=cmdout, stderr=cmderr))

    # read out/err of a command
    cmdout = open(cmdout_p)
    cmderr = open(cmderr_p)

    out = read(cmdout, String)
    err = read(cmderr, String)

    # return all the needed data
    return (
      out     = out,
      err     = err,
      ret     = process.exitcode
    )
  else # non-tempfile-based implementation
    # create pipes/buffers for in/out/err of a command
    cmdin  = IOBuffer(input)
    cmdout = IOBuffer()
    cmderr = IOBuffer()

    if VERSION < v"1.1"
      cmdin  = Pipe()
      cmdout = Pipe()
      cmderr = Pipe()
    end

    # run a process
    process = run(pipeline(ignorestatus(cmd), stdin=cmdin, stdout=cmdout, stderr=cmderr), wait=!(VERSION < v"1.1"))

    if VERSION < v"1.1"
      # close unnecessary communication tunnels of pipes initialized by pipeline()
      close(cmdout.in)
      close(cmderr.in)

      # pass the input to the process and close the related pipe
      # note: this could be also `write(process, input)`, but then `cmdin` would not be used which is not cool
      write(cmdin, input)
      close(cmdin)

      # asynchronously read the outputs of the command
      out = @async String(read(cmdout))
      err = @async String(read(cmderr))

      # return all the needed data
      return (
        out     = fetch(out),
        err     = fetch(err),
        ret     = process.exitcode
      )
    end # if VERSION < v"1.1"

    # read the outputs of the command
    out = String(take!(cmdout))
    err = String(take!(cmderr))

    # return all the needed data
    return (
      out     = out,
      err     = err,
      ret     = process.exitcode
    )
  end
end

"""
    kbmag_bin_wrapper(program::String;
                      params::Array{String,1} = [],
                      input::String = "",
                      execution_dir::String = ".")

Executes a given `program` from the set of kbmag standalone executables with given `parameters` and `input` as the standard input. As kbmag binaries always seek for data in the current working directory, the `execution_dir` parameter determines the local directory in which the binary operates.

# Examples
```julia-repl
julia> KBmag.kbmag_bin_wrapper("kbprog"; params = ["237"], execution_dir = "../kbmag_files")
```
"""
function kbmag_bin_wrapper(program::String;
                           params::Array{String,1} = [],
                           input::String = "",
                           execution_dir::String = ".")

  # remember the current working directory
  call_dir = pwd()
  result = ()

  try
    # WARNING: when calling a kbmag binary we need to make sure that
    # all the input files are in the current working directory
    cd(execution_dir)

    call_path = joinpath(kbmag_bin_dir, program)
    result = low_level_exec(`$call_path $(params)`; input = input)
  catch x
    error("Exception handled: ", x)
  finally
    # change the current working directory back to the previous one
    cd(call_dir)
  end

  return result # (out, err, ret)
end

"""
    kbprog_call(basepath::String)

Calls a `kbprog` binary with the input file determined by the `basepath` parameter. A number of output files with the same basepath, but different extensions, is generated by the `kbprog` binary.

# Examples
```julia-repl
julia> KBmag.kbprog_call("../kbmag_files/237")
```
"""
function kbprog_call(basepath::String)
  # generate an absolute path to the file
  basepath = abspath(basepath)
  # check whether it exists
  isfile(basepath) || error("The $basepath file could not be found.")
  # divide the path into two parts
  basepath_dir, groupname = dirname(basepath), basename(basepath)

  # call a proper binary
  res = kbmag_bin_wrapper("kbprog"; params = [groupname], execution_dir = basepath_dir)

  # assure that the call was successful
  res.ret == 0 || error(res.err)

  # return the whole result
  return res
end

"""
    wordreduce_call(basepath::String, words::Array{String,1})

Calls a `wordreduce` binary with the standard input generated based on the `words` array. Returns an array of reduced words. The `kbprog_call` function is called automatically if any input files do not exist.

# Examples
```julia-repl
julia> KBmag.wordreduce_call("../kbmag_files/237", ["a*a*a*a", "a^4", "b*b", "B*A", "a*A"])
5-element Array{Any,1}:
 "A^3"
 "A^3"
 "B"
 "c"
 ""
```
"""
function wordreduce_call(basepath::String, words::Array{String,1})
  # generate an absolute path to the file
  basepath = abspath(basepath)
  # check whether it exists
  isfile(basepath) || error("The $basepath file could not be found.")
  # divide the path into two parts
  basepath_dir, groupname = dirname(basepath), basename(basepath)

  kbprog_output_files = [
    joinpath(basepath_dir, groupname * ".kbprog"),
    joinpath(basepath_dir, groupname * ".kbprog.ec"),
    joinpath(basepath_dir, groupname * ".reduce")
  ]

  # check whether input files exist and if not, call kbprog
  if !all(isfile.(kbprog_output_files))
    kbprog_res = kbprog_call(basepath)
    # assure that the call was successful
    kbprog_res.ret == 0 || error(kbprog_res.err)
  end

  # prepare a raw input for the wordreduce binary
  raw_input = join(words, ",") * ";"
  # call the wordreduce binary
  res = kbmag_bin_wrapper("wordreduce"; params = ["-kbprog", groupname], input = raw_input, execution_dir = basepath_dir)
  # assure that the call was successful
  res.ret == 0 || error(res.err)

  # prepare an array for the reduced strings...
  output = []
  # ...and fill it with the words extracted from the output of the wordreduce call
  # WARNING: "IdWord" constant is replaced by an empty string for further concat
  for i in eachmatch(r"([^ ]*[^.:])\n", res.out)
    push!(output, i.captures[1] == "IdWord" ? "" : i.captures[1])
  end

  # return the array
  return output
end
